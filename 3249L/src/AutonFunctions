#include "main.h"
#include <cmath>

double InchesToDegrees(float distance){const double diameter = 3.25;double AngleConversion = distance/((M_PI * diameter)/360); return AngleConversion;}

Bot bot;
double DegToRad(double x) {
    return (x * (M_PI/180));
}
double RadToDeg(double x) {
    return (x* (180/M_PI));
}


void Bot::RelativeForward(float distance){

    double Output;
    double I;
    double lastError;
    bot.LTar = InchesToDegrees(distance) + bot.LDeg;
    bot.RTar = InchesToDegrees(distance) + bot.RDeg;
    bot.error = ((bot.LTar - bot.LDeg) + (bot.RTar - bot.LDeg))/2;
    double kP = 30;
    double kI = 0.1;
    double kD = 1;
    while(1){
        bot.error = ((bot.LTar - bot.LDeg) + (bot.RTar - bot.LDeg))/2;
        I=(I+bot.error) * kI;
        Output = (bot.error * kP) + I + ((bot.error - lastError)*kD);
        lastError = error;
        }
}

void Bot::AbsoluteForward(float x,float y){ // x = processed X = processed
    double X = (x - bot.x);
    double Y = (y - bot.y);
    bool TurnLeft;
    double theta;
    double DistanceToCover = sqrt(pow(X,2)+pow(Y,2));
    if(x < 0){//finds the most optimal way to turn
        if(y < 0){
            TurnLeft = false;
            theta = 90 + atan(Y/X);
            //turn Right

        }else {
            TurnLeft = true;
            theta = asin(X/DistanceToCover);
            //turn left

        }
    }else if(y<0){
        TurnLeft = false;
        theta = std::abs(atan(Y/X));
        // turn Right
    }else {
        TurnLeft = true;
        theta = atan(Y/X);
        //turn Left
    }
    while (1){ // rotation first

    }
    
}